<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<meta http-equiv="X-UA-Compatible" content="ie=edge">
		<title>Events</title>
		<link rel="stylesheet" href="dependencies/reset.css">
		<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/sakura.css/css/sakura.css" type="text/css">
		<link rel="stylesheet" href="dependencies/chota-grid.css">
		<link rel="stylesheet" href="styles/style.css">
		<!--<link rel="icon" href="favicon.ico" type="image/x-icon">-->
	</head>
	<body>
		<div id="app">
			<main>
				<div v-if="urlHash" class="event-display">
					<div class="event-square">
						<div class="title">
							<h1 v-text="event.title"></h1>
						</div>
						<div class="when-and-where">
							<div v-text="event.location"></div>
							<div>&bull;</div>
							<div v-text="event.startDatetime"></div>
							<div>&ndash;</div>
							<div v-text="event.endDatetime"></div>
							<div v-text="event.timezone"></div>
						</div>
						<div class="rsvp">
							<div class="col" v-text="event.rsvp"></div>
							<div class="col" v-text="event.rsvpDate"></div>
						</div>
						<div class="description">
							<div class="col" v-text="event.description"></div>
						</div>
					</div>
				</div>
				<h1>Edit</h1>
				<form>
					<div class="row">
						<div class="col-8">
							<label for="title">Title</label>
		  					<input type="text" id="title" name="title" v-model="event.title" placeholder="My Event">
						</div>
						<div class="col">
							<label for="location">Location</label>
		  					<input type="text" id="location" name="location" v-model="event.location" placeholder="Location TBA">
						</div>
					</div>
					<div class="row">
						<div class="col">
							<label for="start-datetime">Start</label>
		  					<input type="datetime-local" id="start-datetime" name="start-datetime" v-model="event.startDatetime" placeholder="2026-01-01">
						</div>
						<div class="col">
							<label for="end-datetime">End</label>
		  					<input type="datetime-local" id="end-datetime" name="end-datetime" v-model="event.endDatetime" placeholder="2026-01-01">
						</div>
						<div class="col">
							<label for="timezone">Timezone</label>
	  						<input type="text" id="timezone" name="timezone" v-model="event.timezone" placeholder="ACDT">
						</div>
					</div>
					<div class="row">
						<div class="col">
							<label for="rsvp">RSVP</label>
	  						<input type="text" id="rsvp" name="rsvp" v-model="event.rsvp" placeholder="eventorganiser@example.com">
						</div>
						<div class="col">
							<label for="rsvp-date">RSVP Date</label>
	  						<input type="date" id="rsvp-date" name="rsvp-date" v-model="event.rsvpDate" placeholder="2026-01-01">
						</div>
					</div>
					<div class="row">
						<div class="col">
							<label for="image-url">Image URL</label>
	  						<input type="url" id="image-url" name="image-url" v-model="event.imageUrl" placeholder="https://example.com/event-poster.png">
						</div>
						<div class="col">
							<label for="theme">Theme</label>
	  						<input type="text" id="theme" name="theme" v-model="event.theme" placeholder="party">
						</div>
						<div class="col">
							<label for="rng">RNG</label>
	  						<input type="number" min="0" max="999" step="1" id="rng" name="rng" v-model="event.rng">
						</div>
					</div>
					<div class="row">
						<div class="col">
							<label for="description">Description</label>
	  						<textarea id="description" name="description" v-model="event.description" placeholder="Description here"></textarea>
						</div>
					</div>
				</form>
				<h1>Links</h1>
				<url-display :url="eventUrl"></url-display>
				<url-display :url="eventUrlSmallestEncoded"></url-display>
			</main>
		</div>
		<template id="url-display">
			<div>
				<div class="url-preview-row">
					<div class="url-preview">
						<div class="url-base" v-text="url?.urlBase"></div>
						<icon-hash class="hash-icon"></icon-hash>
						<code v-text="url?.urlHash"></code>
					</div>
					<button class="copy-button" @click="copyUrlToClipboard()">
						<icon-clipboard-check v-if="copied" class="copied"></icon-clipboard-check>
						<icon-clipboard v-else></icon-clipboard>
					</button>
				</div>
				<div class="url-stats">
					<div class="compatibility-heading">Compatibility:</div>
					<div><span v-text="url?.charCount"></span> chars</div>
					<div>&bull;</div>
					<div>Instagram: <span v-if="url?.compatibleWithIG">Yea</span><span v-else>Nay</span></div>
				</div>
			</div>
		</template>
		<template id="icon-clipboard">
			<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-clipboard" viewBox="0 0 16 16">
				<path d="M4 1.5H3a2 2 0 0 0-2 2V14a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V3.5a2 2 0 0 0-2-2h-1v1h1a1 1 0 0 1 1 1V14a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V3.5a1 1 0 0 1 1-1h1z"/>
				<path d="M9.5 1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5zm-3-1A1.5 1.5 0 0 0 5 1.5v1A1.5 1.5 0 0 0 6.5 4h3A1.5 1.5 0 0 0 11 2.5v-1A1.5 1.5 0 0 0 9.5 0z"/>
			</svg>
		</template>
		<template id="icon-clipboard-check">
			<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-clipboard-check" viewBox="0 0 16 16">
				<path fill-rule="evenodd" d="M10.854 7.146a.5.5 0 0 1 0 .708l-3 3a.5.5 0 0 1-.708 0l-1.5-1.5a.5.5 0 1 1 .708-.708L7.5 9.793l2.646-2.647a.5.5 0 0 1 .708 0"/>
				<path d="M4 1.5H3a2 2 0 0 0-2 2V14a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V3.5a2 2 0 0 0-2-2h-1v1h1a1 1 0 0 1 1 1V14a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V3.5a1 1 0 0 1 1-1h1z"/>
				<path d="M9.5 1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5zm-3-1A1.5 1.5 0 0 0 5 1.5v1A1.5 1.5 0 0 0 6.5 4h3A1.5 1.5 0 0 0 11 2.5v-1A1.5 1.5 0 0 0 9.5 0z"/>
			</svg>
		</template>
		<template id="icon-hash">
			<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-hash" viewBox="0 0 16 16">
				<path d="M8.39 12.648a1 1 0 0 0-.015.18c0 .305.21.508.5.508.266 0 .492-.172.555-.477l.554-2.703h1.204c.421 0 .617-.234.617-.547 0-.312-.188-.53-.617-.53h-.985l.516-2.524h1.265c.43 0 .618-.227.618-.547 0-.313-.188-.524-.618-.524h-1.046l.476-2.304a1 1 0 0 0 .016-.164.51.51 0 0 0-.516-.516.54.54 0 0 0-.539.43l-.523 2.554H7.617l.477-2.304c.008-.04.015-.118.015-.164a.51.51 0 0 0-.523-.516.54.54 0 0 0-.531.43L6.53 5.484H5.414c-.43 0-.617.22-.617.532s.187.539.617.539h.906l-.515 2.523H4.609c-.421 0-.609.219-.609.531s.188.547.61.547h.976l-.516 2.492c-.008.04-.015.125-.015.18 0 .305.21.508.5.508.265 0 .492-.172.554-.477l.555-2.703h2.242zm-1-6.109h2.266l-.515 2.563H6.859l.532-2.563z"/>
			</svg>
		</template>
		<script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
		<script src="https://unpkg.com/vue-async-computed@4.0.1"></script>
		<script src="dependencies/UniBinary.js"></script>
		<script src="dependencies/compress.js"></script>
		<script src="scripts/index.js"></script>
		<script>
			class EventUrlInfo {
				constructor(urlBase, urlHash) {
					this.urlBase = urlBase;
					this.urlHash = urlHash;
					this.fullUrl = this.urlBase + '#' + this.urlHash;
					this.charCount = this.fullUrl.length;
					this.compatibleWithIG = this.charCount <= 245;
				}
			}

			class Event {
				constructor(title, location, startDatetime, endDatetime, timezone, rsvp, rsvpDate, imageUrl, theme, rng, description) {
					this.title = title;
					this.location = location;
					this.startDatetime = startDatetime;
					this.endDatetime = endDatetime;
					this.timezone = timezone;
					this.rsvp = rsvp;
					this.rsvpDate = rsvpDate;
					this.imageUrl = imageUrl;
					this.theme = theme;
					this.rng = rng;
					this.description = description;
				}
			}
			
			const urlDisplayComponent = {
				template: "#url-display",
				components: {
					IconClipboard: { template: "#icon-clipboard" },
					IconClipboardCheck: { template: "#icon-clipboard-check" },
					IconHash: { template: "#icon-hash" },
				},
				props: {
					url: EventUrlInfo
				},
				data() {
					return {
						copied: false
					}
				},
				methods: {
					copyUrlToClipboard() {
						navigator.clipboard.writeText(this.url.fullUrl);
						this.copied = true;
						setTimeout(() => { this.copied = false; }, 2000);
					}
				}
			};
			
			const app = Vue.createApp({
				components: {
					UrlDisplay: urlDisplayComponent,
				},
				data() {
					return {
						event: new Event("", "", "", "", "", "", "", "", "", this.randomInt(0,999), ""),
						urlBase: this.getUrlBase(),
						urlHash: window.location.hash.replace(/^#/, '')
					};
				},
				methods: {
					encode(str) {
						return unibinary.encodeString(str);
					},
					async compressAndEncode(str) {
						return unibinary.encode(await compress(str));
					},
					decode(str) {
						try { return unibinary.decodeString(str); }
						catch { return null; }
					},
					async decodeAndDecompress(str) {
						try { return await decompress(unibinary.decode(str)); }
						catch { return null; }
					},
					formatDate(datetime) {
						const match = datetime?.match(/\d\d\d\d-\d\d-\d\d/);
						return match && match[0]?.replace(/-/g, '') || '';
					},
					formatDatetime(datetime) {
						const match = datetime?.match(/\d\d\d\d-\d\d-\d\dT\d\d:\d\d/);
						return match && match[0]?.replace(/\D/g, '') || '';
					},
					formatTheme(theme, rng) {
						if (!theme) return "";
						if (!rng) return "";
						if (rng < 0 || rng > 999) return "";
						if (!/^[a-zA-Z\-]+$/.test(theme)) return "";
						return theme.toLowerCase() + rng;
					},
					escapeEventStringPart(str) {
						// Unfriendly characters are escaped in the same way as a URI except using '~' rather than '%'.
						// E.g. a line feed becomes '~0A' rather than '%0A'
						// This avoids conflicts with regular URI encoding/decoding, which might also happen when copying links around, depending on the browser
						// Spaces are also replaced with pluses
						
						if (!str) return "";
						let newStr = "";
						for (let char of str) {
							if (char === "~") newStr += '~7E'; // escape tildes
							else if (char === "|") newStr += "~7C"; // escape pipes
							else if (char === "+") newStr += "~2B"; // escape pluses
							else if (char === " ") newStr += "+"; // replace spaces with pluses
							else if (char === "`") newStr += "~60"; // escape backticks (needed for some reason, not sure why)
							else if (/\!\@\$\%\^\&\*\(\)\_\+\-\=\[\]\{\}\\\;\:\'\"\,\<\.\>\/\?/.test(char)) newStr += char; // keep these symbols
							else if (/\p{Letter}|\p{Number}|\p{Mark}|\p{Symbol}|\p{Punctuation}/u.test(char)) newStr += char; // keep everything in unicode other than control/separator characters
							else newStr += encodeURIComponent(char).replace("%", "~"); // escape all other fancy symbols like newlines, tabs, em spaces, RTL control characters, etc
						}
						return newStr;
					},
					unescapeEventStringPart(str) {
						if (!str) return "";
						return decodeURIComponent(str.replace(/\+/g, " ").replace(/\~/g, "%"));
						
						/*
						let newStr = "";
						for (let i = 0; i < str.length; ) {
							if (str.charAt(i) === "+") { newStr += " "; i++; continue; }
							
							const chunk = str.substring(i, i + 3);
							if (chunk === "~7E") { newStr += "~"; i += 3; continue; }
							if (chunk === "~7C") { newStr += "|"; i += 3; continue; }
							if (chunk === "~2B") { newStr += "+"; i += 3; continue; }
							if (chunk === "~60") { newStr += "`"; i += 3; continue; }

							for (let j = i + 3; j < str.length; ) {
								let bigChunk = str.substring(i, j);
								if (/^(\~[0-9a-fA-F][0-9a-fA-F])$/.test(bigChunk))
								newStr += decodeURIComponent(chunk.replace("~", "%"))
							}
						} */
					},
					parseDatetime(datestr) {
						if (!datestr) return null;
						const match = datestr.match(/^((?<yyyy>\d\d\d\d)(?<MM>\d\d)(?<dd>\d\d))((?<hh>\d\d)(?<mm>\d\d))?$/);
						if (!match) return null;
						const groups = match.groups;
						const date = (groups.yyyy && groups.MM && groups.dd) ? (groups.yyyy + "-" + groups.MM + "-" + groups.dd) : null;
						const time = (groups.hh && groups.mm) ? (groups.hh + ":" + groups.mm) : null;
						if (!date) return null;
						if (!!groups.hh !== !!groups.mm) return null; // time is partly present - fail fast by returning null
						return date + (time ? "T" + time : "");
					},
					randomInt(min, max) { // returns a number inclusive of min and max
						return Math.floor(Math.random() * (max + 1 - min) + min);
					},
					getUrlBase() {
						return (window.location.host + window.location.pathname).replace(/[\/\\]+$/,'');
					},
					parseEventString(str) {
						if (!str) return null;
						const arr = str.split("|");
						if (arr.length < 3) return null; // require at least a title, location, and start time

						const themeMatch = arr[7] && arr[7].match(/^(?<theme>[a-zA-Z]+)(?<rng>[0-9][0-9][0-9])$/);
						const theme = themeMatch && themeMatch.groups.theme?.toLowerCase();
						const rng = Number(themeMatch && themeMatch.groups.rng || this.randomInt(0,999));

						// Reject this event string if there are malformed dates (it has probably been parsed wrong, i.e. we should have used unibinDecode)
						// Don't reject if the dates are absent entirely
						const start = this.parseDatetime(arr[2]);
						const end = this.parseDatetime(arr[3]);
						if (arr[2] && !start) return null;
						if (arr[3] && !end) return null;
						
						return {
							title: this.unescapeEventStringPart(arr[0]) || "",
							location: this.unescapeEventStringPart(arr[1]) || "",
							startDatetime: start || "",
							endDatetime: end || "",
							timezone: this.unescapeEventStringPart(arr[4]) || "",
							rsvp: this.unescapeEventStringPart(arr[5]) || "",
							rsvpDate: this.parseDatetime(arr[6]) || "",
							imageUrl: !theme ? this.unescapeEventStringPart(arr[7]) : "",
							theme: theme || "",
							rng: rng,
							description: this.unescapeEventStringPart(arr[8]) || ""
						}
					},
					async loadEventFromUrlHash(urlHash) {
						for (const decompress of [false, true]) {
							for (const unibinDecode of [false, true]) {
								if (!unibinDecode && decompress) continue; // this combination never occurs in practice; skip this loop iteration
								for (const uriDecode of [false, true]) {
									let str = urlHash;
									if (uriDecode) str = decodeURIComponent(str);
									if (unibinDecode && !decompress) str = this.decode(str);
									if (unibinDecode && decompress) str = await this.decodeAndDecompress(str);

									const evt = this.parseEventString(str);
									console.log(decompress + ", " + unibinDecode + ", " + uriDecode + ":");
									console.log(evt);
									
									if (evt) {
										this.event = evt;
										return; // break out of all loops
									}
								}
							}
						}
					}
				},
				computed: {
					eventString() {
						return (
							this.escapeEventStringPart(this.event.title) + "|" +
							this.escapeEventStringPart(this.event.location) + "|" +
							this.formatDatetime(this.event.startDatetime) + "|" +
							this.formatDatetime(this.event.endDatetime) + "|" +
							this.escapeEventStringPart(this.event.timezone) + "|" +
							this.escapeEventStringPart(this.event.rsvp) + "|" +
							this.formatDate(this.event.rsvpDate) + "|" +
							(this.escapeEventStringPart(this.event.imageUrl) || this.formatTheme(this.event.theme, this.event.rng)) + "|" +
							this.escapeEventStringPart(this.event.description)
						);
					},
					eventStringEncoded() { return this.encode(this.eventString); },
					eventUrl() { return new EventUrlInfo(this.urlBase, this.eventString) },
					eventUrlEncoded() { return new EventUrlInfo(this.urlBase, this.eventStringEncoded) },
				},
				asyncComputed: {
					async eventStringCompressedEncoded() { return await this.compressAndEncode(this.eventString); },
					async eventUrlCompressedEncoded() { return new EventUrlInfo(this.urlBase, await this.eventStringCompressedEncoded) },
					async eventUrlSmallestEncoded() {
						const a = this.eventStringEncoded;
						const b = await this.eventStringCompressedEncoded;
						const smallest = a?.length <= b?.length ? a : b;
						return new EventUrlInfo(this.urlBase, smallest);
					},
				},
				beforeMount() {
					if (this.urlHash) {
						this.loadEventFromUrlHash(this.urlHash); // don't wait for async method to return (even if we tried to wait, Vue would continue anyway)
					}
				}
			});
			app.use(AsyncComputed);
			app.mount('#app');
		</script>
	</body>
</html>
